name: Continuous Integration

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    outputs:
      artifact-errors-only: ${{ steps.check-artifacts.outputs.artifact-errors-only }}
      has-artifacts: ${{ steps.check-artifacts.outputs.has-artifacts }}
    strategy:
      matrix:
        node-version: [18.x]

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        # This single cache step is sufficient for the entire monorepo
        cache: 'npm'

    - name: Install all dependencies
      # Use npm ci for root and frontend (have package-lock.json), npm install for backend (no package-lock.json)
      run: |
        npm ci
        cd frontend && npm ci
        cd ../backend && npm install

    - name: Lint backend code
      run: cd backend && npm run lint

    - name: Run frontend tests
      run: cd frontend && npm run test:ci

    - name: Run backend tests
      run: cd backend && npm test -- --detectOpenHandles --verbose
      env:
        NODE_ENV: test
        FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
        FIREBASE_CLIENT_EMAIL: ${{ secrets.FIREBASE_CLIENT_EMAIL }}
        FIREBASE_PRIVATE_KEY: ${{ secrets.FIREBASE_PRIVATE_KEY }}
        FIREBASE_API_KEY: ${{ secrets.FIREBASE_API_KEY }}
        FIREBASE_AUTH_DOMAIN: ${{ secrets.FIREBASE_AUTH_DOMAIN }}
        FIREBASE_STORAGE_BUCKET: ${{ secrets.FIREBASE_STORAGE_BUCKET }}
        FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.FIREBASE_MESSAGING_SENDER_ID }}
        FIREBASE_APP_ID: ${{ secrets.FIREBASE_APP_ID }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
        STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
        STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
        STRIPE_WEBHOOK_ID: ${{ secrets.STRIPE_WEBHOOK_ID }}
        STRIPE_GURU_PASS_PRICE_ID: ${{ secrets.STRIPE_GURU_PASS_PRICE_ID }}
        STRIPE_SKILL_VERIFICATION_PRICE_ID: ${{ secrets.STRIPE_SKILL_VERIFICATION_PRICE_ID }}
        STRIPE_TRUST_SAFETY_PRICE_ID: ${{ secrets.STRIPE_TRUST_SAFETY_PRICE_ID }}

    - name: Build frontend
      run: cd frontend && npm run build
      env:
        # The CI=false environment variable prevents warnings from being treated as errors during the build process.
        CI: false

    - name: Handle runtime log artifacts
      id: check-artifacts
      run: |
        chmod +x .github/scripts/handle-artifacts.sh
        .github/scripts/handle-artifacts.sh check
    
    - name: Upload runtime log artifacts (conditional)
      if: steps.check-artifacts.outputs.has-artifacts == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: runtime-logs
        path: |
          /home/runner/work/_temp/runtime-logs/blocked.jsonl
          /home/runner/work/_temp/runtime-logs/blocked.md
        retention-days: 30
        if-no-files-found: ignore
      continue-on-error: true

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    # This job will only run after the 'build-and-test' job has successfully completed for all matrix variations.
    needs: [build-and-test]
    if: github.ref == 'refs/heads/main'
    outputs:
      deployment-status: ${{ steps.deployment.outputs.status }}
      artifact-errors-only: ${{ steps.check-errors.outputs.artifact-errors-only }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Check for artifact-only errors
      id: check-errors
      run: |
        # This step checks if the only errors in the workflow are artifact-related
        # This helps prevent Copilot agents from getting stuck in comment loops
        
        ARTIFACT_ERRORS_ONLY="false"
        
        # Check if the build-and-test job had any artifact-related outputs
        if [ "${{ needs.build-and-test.outputs.artifact-errors-only || 'false' }}" == "true" ]; then
          ARTIFACT_ERRORS_ONLY="true"
          echo "âœ… Detected artifact-only error condition"
          echo "ðŸ“ This indicates a successful build with missing optional runtime logs"
        else
          echo "â„¹ï¸ No artifact-only error conditions detected"
        fi
        
        echo "artifact-errors-only=${ARTIFACT_ERRORS_ONLY}" >> $GITHUB_OUTPUT
        
        # Also check for missing artifacts from previous steps (for PRs)
        if [ -n "${{ github.event.pull_request }}" ]; then
          echo "ðŸ” PR context detected - checking for artifact-only issues"
          if [ "${ARTIFACT_ERRORS_ONLY}" == "true" ]; then
            echo "pr-safe-to-close=true" >> $GITHUB_OUTPUT
            echo "âœ… PR appears to have only artifact issues - safe for auto-closure"
          else
            echo "pr-safe-to-close=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ PR has non-artifact issues - manual review required"
          fi
        fi
    
    - name: Deploy to production
      id: deployment
      run: |
        echo "Deploy to production environment"
        echo "status=success" >> $GITHUB_OUTPUT
        # Add your production deployment commands here

